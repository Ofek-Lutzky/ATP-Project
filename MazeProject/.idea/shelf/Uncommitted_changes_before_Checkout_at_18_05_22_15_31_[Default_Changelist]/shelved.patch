Index: src/algorithms/search/BestFirstSearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.search;\r\n\r\nimport java.util.Comparator;\r\nimport java.util.PriorityQueue;\r\n\r\npublic class BestFirstSearch extends BreadthFirstSearch{\r\n\r\n    public BestFirstSearch() {\r\n        this.setName(\"BestFirstSearch\");\r\n        this.openList = new PriorityQueue<AState>(Comparator.comparing(AState::getCost));\r\n\r\n        //todo maybe we can make a new comperator class but not shore in what way do so\r\n        //todo check how to remove the getCost from Astate\r\n//        this.openList=  new PriorityQueue<AState>(new Comparator<AState>() {\r\n//\r\n//            @Override\r\n//            public int compare(AState o1, AState o2) {\r\n//\r\n//                return 0;\r\n//            }\r\n//\r\n//            public double getCost() {\r\n//                if (this.getCameFrom() == null){\r\n//                    return 0;\r\n//                }\r\n//                if (isSlant()){\r\n//                    return 15;\r\n//                }\r\n//                else{\r\n//                    return 10;\r\n//                }\r\n//            }\r\n//\r\n//            private boolean isSlant(){\r\n//                int fatherRow = ((MazeState)this.getCameFrom()).getRow();\r\n//                int fatherColumn = ((MazeState)this.getCameFrom()).getColumn();\r\n//                if (fatherRow+1 == this.getRow() && fatherColumn+1 == this.getColumn() ||\r\n//                        fatherRow-1 == this.getRow() && fatherColumn+1 == this.getColumn() ||\r\n//                        fatherRow+1 == this.getRow() && fatherColumn-1 == this.getColumn() ||\r\n//                        fatherRow-1 == this.getRow() && fatherColumn-1 == this.getColumn()){\r\n//                    return true;\r\n//                }\r\n//\r\n//                return false;\r\n//            }\r\n//        });\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algorithms/search/BestFirstSearch.java b/src/algorithms/search/BestFirstSearch.java
--- a/src/algorithms/search/BestFirstSearch.java	(revision 7d9f2ce57fcb3a6f6e335b90a8a71b655548af35)
+++ b/src/algorithms/search/BestFirstSearch.java	(date 1652876576357)
@@ -6,44 +6,13 @@
 public class BestFirstSearch extends BreadthFirstSearch{
 
     public BestFirstSearch() {
-        this.setName("BestFirstSearch");
+        //this.setName("BestFirstSearch");
         this.openList = new PriorityQueue<AState>(Comparator.comparing(AState::getCost));
+    }
 
-        //todo maybe we can make a new comperator class but not shore in what way do so
-        //todo check how to remove the getCost from Astate
-//        this.openList=  new PriorityQueue<AState>(new Comparator<AState>() {
-//
-//            @Override
-//            public int compare(AState o1, AState o2) {
-//
-//                return 0;
-//            }
-//
-//            public double getCost() {
-//                if (this.getCameFrom() == null){
-//                    return 0;
-//                }
-//                if (isSlant()){
-//                    return 15;
-//                }
-//                else{
-//                    return 10;
-//                }
-//            }
-//
-//            private boolean isSlant(){
-//                int fatherRow = ((MazeState)this.getCameFrom()).getRow();
-//                int fatherColumn = ((MazeState)this.getCameFrom()).getColumn();
-//                if (fatherRow+1 == this.getRow() && fatherColumn+1 == this.getColumn() ||
-//                        fatherRow-1 == this.getRow() && fatherColumn+1 == this.getColumn() ||
-//                        fatherRow+1 == this.getRow() && fatherColumn-1 == this.getColumn() ||
-//                        fatherRow-1 == this.getRow() && fatherColumn-1 == this.getColumn()){
-//                    return true;
-//                }
-//
-//                return false;
-//            }
-//        });
+    @Override
+    public String getName() {
+        return "BestFirstSearch";
     }
 
 }
Index: src/algorithms/search/BreadthFirstSearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.search;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedList;\r\nimport java.util.Stack;\r\n\r\npublic class BreadthFirstSearch extends ASearchingAlgorithm{\r\n    public BreadthFirstSearch() {\r\n        this.setName(\"BreadthFirstSearch\");\r\n        this.openList = new LinkedList<AState>();\r\n    }\r\n\r\n\r\n//    @Override\r\n//    public Solution solve(ISearchable s) {\r\n//        //the Hash is to store the Astates we all ready reached\r\n//        HashSet<AState> visited = new HashSet<>();\r\n//        this.openList.add(s.getStartState());\r\n////        boolean gotToEnd = false;\r\n//        AState rtnNode = null;\r\n//\r\n//        while(!this.openList.isEmpty()){\r\n//\r\n//            this.addOneToVisited();\r\n//\r\n//            AState currentState = this.openList.remove();\r\n//            visited.add(currentState);\r\n//\r\n//            if (currentState.equals(s.getGoalState())){\r\n//                rtnNode = currentState;\r\n//                break;\r\n//            }\r\n//\r\n//            ArrayList<AState> nb = s.getAllPossibleStates(currentState);\r\n//\r\n//\r\n//            for (int i = 0; i < nb.size(); i++){\r\n//                if (!compare(visited, nb.get(i))){\r\n//                    this.openList.add(nb.get(i));\r\n//                    nb.get(i).setCameFrom(currentState);\r\n//                }\r\n//            }\r\n//        }\r\n//\r\n//        Solution sol = new Solution();\r\n//\r\n//        while (rtnNode.getCameFrom() != null){\r\n//            sol.addToSolution(rtnNode);\r\n//            rtnNode = rtnNode.getCameFrom();\r\n//        }\r\n//\r\n//        return sol;\r\n//    }\r\n\r\n\r\n    //todo : 1. the contain method not working and the run time is raise because of this .\r\n    //todo 2. משום מה זה ניגש לשיטת get שבניתי\r\n    //todo 3. אולי צריך איזה משהו עם hashcode\r\n    //todo 4. המבנה של האלגוריתם פה שמוסתר נראה לי יותר נכון\r\n    @Override\r\n    public Solution solve(ISearchable s) {\r\n        //the Hash is to store the Astates we all ready reached\r\n        HashSet<AState> visited = new HashSet<>();\r\n        this.openList.add(s.getStartState());\r\n\r\n        AState currentState = s.getStartState();\r\n\r\n        //the loop repeats we get to the goal\r\n        while(!currentState.equals(s.getGoalState())){\r\n\r\n            this.addOneToVisited();\r\n\r\n            visited.add(currentState);\r\n\r\n            ArrayList<AState> nb = s.getAllPossibleStates(currentState);\r\n\r\n            for (int i = 0; i < nb.size(); i++){\r\n                if (!compare(visited, nb.get(i))){\r\n                //if (!visited.contains(nb.get(i))){\r\n                    this.openList.add(nb.get(i));\r\n                    nb.get(i).setCameFrom(currentState);\r\n                }\r\n            }\r\n\r\n            currentState = this.openList.remove();\r\n        }\r\n\r\n        Solution sol = new Solution();\r\n\r\n        while (currentState.getCameFrom() != null){\r\n            sol.addToSolution(currentState);\r\n            currentState = currentState.getCameFrom();\r\n        }\r\n\r\n        return sol;\r\n    }\r\n\r\n\r\n\r\n\r\n    private Boolean compare(HashSet<AState> visited,AState s){\r\n        Object[] a = visited.toArray();\r\n        for (int i = 0; i < a.length; i++){\r\n            if (a[i].equals(s)){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algorithms/search/BreadthFirstSearch.java b/src/algorithms/search/BreadthFirstSearch.java
--- a/src/algorithms/search/BreadthFirstSearch.java	(revision 7d9f2ce57fcb3a6f6e335b90a8a71b655548af35)
+++ b/src/algorithms/search/BreadthFirstSearch.java	(date 1652876576364)
@@ -7,7 +7,7 @@
 
 public class BreadthFirstSearch extends ASearchingAlgorithm{
     public BreadthFirstSearch() {
-        this.setName("BreadthFirstSearch");
+        //this.setName("BreadthFirstSearch");
         this.openList = new LinkedList<AState>();
     }
 
@@ -96,7 +96,10 @@
         return sol;
     }
 
-
+    @Override
+    public String getName() {
+        return "BreadthFirstSearch";
+    }
 
 
     private Boolean compare(HashSet<AState> visited,AState s){
Index: src/algorithms/search/DepthFirstSearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.search;\r\n\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Stack;\r\n\r\npublic class DepthFirstSearch extends ASearchingAlgorithm{\r\n\r\n    public DepthFirstSearch() {\r\n        this.setName(\"DepthFirstSearch\");\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param s\r\n     * @return rtnNode\r\n     */\r\n\r\n    @Override\r\n    public Solution solve(ISearchable s) {\r\n        AState rtnNode = null;\r\n\r\n        Stack<AState> stack = new Stack<>();\r\n        HashSet<AState> visited = new HashSet<>();\r\n\r\n        stack.push(s.getStartState());\r\n\r\n        while(!stack.empty()){\r\n\r\n            this.addOneToVisited();\r\n\r\n            AState currentState = stack.pop();\r\n            visited.add(currentState);\r\n\r\n            if (currentState.equals(s.getGoalState())){\r\n                rtnNode = currentState;\r\n                break;\r\n            }\r\n\r\n            ArrayList<AState> nb = s.getAllPossibleStates(currentState);\r\n\r\n            //todo if the contain was working\r\n//            for (int i = 0; i < nb.size(); i++){\r\n//                if (!visited.contains(nb.get(i))){\r\n//                    stack.push(nb.get(i));\r\n//                    nb.get(i).setCameFrom(currentState);\r\n//                }\r\n//            }\r\n\r\n            for (int i = 0; i < nb.size(); i++){\r\n                if (!compare(visited, nb.get(i))){\r\n                    stack.push(nb.get(i));\r\n                    nb.get(i).setCameFrom(currentState);\r\n                }\r\n            }\r\n        }\r\n\r\n        Solution sol = new Solution();\r\n        while (rtnNode.getCameFrom() != null){\r\n            sol.addToSolution(rtnNode);\r\n            rtnNode = rtnNode.getCameFrom();\r\n        }\r\n\r\n        return sol;\r\n    }\r\n\r\n    //todo i did function instead of the contain method\r\n    private Boolean compare(HashSet<AState> visited,AState s){\r\n        Object[] a = visited.toArray();\r\n        for (int i = 0; i < a.length; i++){\r\n            if (a[i].equals(s)){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algorithms/search/DepthFirstSearch.java b/src/algorithms/search/DepthFirstSearch.java
--- a/src/algorithms/search/DepthFirstSearch.java	(revision 7d9f2ce57fcb3a6f6e335b90a8a71b655548af35)
+++ b/src/algorithms/search/DepthFirstSearch.java	(date 1652876576369)
@@ -8,7 +8,8 @@
 public class DepthFirstSearch extends ASearchingAlgorithm{
 
     public DepthFirstSearch() {
-        this.setName("DepthFirstSearch");
+
+        //this.setName("DepthFirstSearch");
     }
 
     /**
@@ -65,6 +66,11 @@
         return sol;
     }
 
+    @Override
+    public String getName() {
+        return "DepthFirstSearch";
+    }
+
     //todo i did function instead of the contain method
     private Boolean compare(HashSet<AState> visited,AState s){
         Object[] a = visited.toArray();
Index: src/algorithms/search/ASearchingAlgorithm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package algorithms.search;\r\nimport java.util.PriorityQueue;\r\nimport java.util.Queue;\r\n\r\npublic abstract class ASearchingAlgorithm implements ISearchingAlgorithm{\r\n\r\n    //todo if need this here or as field of the subClasses\r\n    Queue<AState> openList;\r\n    private int visitedNodes;\r\n    private String name;\r\n\r\n    public ASearchingAlgorithm() {\r\n        this.visitedNodes = 0;\r\n    }\r\n\r\n    @Override\r\n    public abstract Solution solve(ISearchable s);\r\n\r\n\r\n    public void addOneToVisited(){this.visitedNodes++;}\r\n\r\n    @Override\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public int getNumberOfNodesEvaluated(){return this.visitedNodes;}\r\n\r\n    public void setName(String s){\r\n        this.name = s;\r\n    }\r\n\r\n//    public void addOpenList(AState s){\r\n//        this.openList.add(s);\r\n//    }\r\n//\r\n//    public PriorityQueue<AState> getOpenList(){\r\n//        return this.openList;\r\n//    }\r\n\r\n//    public AState dequeFromQueue(){\r\n//        return this.openList.poll();\r\n//    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algorithms/search/ASearchingAlgorithm.java b/src/algorithms/search/ASearchingAlgorithm.java
--- a/src/algorithms/search/ASearchingAlgorithm.java	(revision 7d9f2ce57fcb3a6f6e335b90a8a71b655548af35)
+++ b/src/algorithms/search/ASearchingAlgorithm.java	(date 1652876576374)
@@ -1,4 +1,6 @@
 package algorithms.search;
+import org.junit.Test;
+
 import java.util.PriorityQueue;
 import java.util.Queue;
 
@@ -7,28 +9,26 @@
     //todo if need this here or as field of the subClasses
     Queue<AState> openList;
     private int visitedNodes;
-    private String name;
+    //private String name;
 
     public ASearchingAlgorithm() {
         this.visitedNodes = 0;
     }
 
+
     @Override
     public abstract Solution solve(ISearchable s);
 
 
     public void addOneToVisited(){this.visitedNodes++;}
 
-    @Override
-    public String getName() {
-        return this.name;
-    }
+    public abstract String getName();
 
     public int getNumberOfNodesEvaluated(){return this.visitedNodes;}
 
-    public void setName(String s){
-        this.name = s;
-    }
+//    public void setName(String s){
+//        this.name = s;
+//    }
 
 //    public void addOpenList(AState s){
 //        this.openList.add(s);
Index: MazeProject.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/MazeProject.iml b/MazeProject.iml
--- a/MazeProject.iml	(revision 7d9f2ce57fcb3a6f6e335b90a8a71b655548af35)
+++ b/MazeProject.iml	(date 1652876576381)
@@ -3,9 +3,36 @@
   <component name="NewModuleRootManager" inherit-compiler-output="true">
     <exclude-output />
     <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/JUnit" isTestSource="true" />
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module-library">
+      <library name="JUnit4">
+        <CLASSES>
+          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+    <orderEntry type="module-library" scope="TEST">
+      <library name="JUnit5.7.0">
+        <CLASSES>
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.7.0/junit-jupiter-5.7.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.7.0/junit-jupiter-api-5.7.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.0/apiguardian-api-1.1.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.7.0/junit-platform-commons-1.7.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.7.0/junit-jupiter-params-5.7.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.7.0/junit-jupiter-engine-5.7.0.jar!/" />
+          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.7.0/junit-platform-engine-1.7.0.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
   </component>
 </module>
\ No newline at end of file
